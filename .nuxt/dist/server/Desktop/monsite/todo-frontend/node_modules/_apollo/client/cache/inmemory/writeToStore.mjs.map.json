{"file":"writeToStore.mjs","mappings":"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","names":["StoreWriter","_a","dataId","context","value","selectionSet"],"sources":["../../../../../../../../../../../node_modules/@apollo/client/cache/inmemory/writeToStore.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { Kind } from \"graphql\";\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, canonicalStringify, } from \"../../utilities/index.js\";\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext, } from \"./helpers.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor(context, clientOnly, deferred) {\n    var key = \"\".concat(clientOnly).concat(deferred);\n    var flavored = context.flavors.get(key);\n    if (!flavored) {\n        context.flavors.set(key, (flavored =\n            context.clientOnly === clientOnly && context.deferred === deferred ?\n                context\n                : __assign(__assign({}, context), { clientOnly: clientOnly, deferred: deferred })));\n    }\n    return flavored;\n}\nvar StoreWriter = /** @class */ (function () {\n    function StoreWriter(cache, reader, fragments) {\n        this.cache = cache;\n        this.reader = reader;\n        this.fragments = fragments;\n    }\n    StoreWriter.prototype.writeToStore = function (store, _a) {\n        var _this = this;\n        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\n        var operationDefinition = getOperationDefinition(query);\n        var merger = makeProcessedFieldsMerger();\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n        var context = __assign(__assign({ store: store, written: Object.create(null), merge: function (existing, incoming) {\n                return merger.merge(existing, incoming);\n            }, variables: variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: new Map(), clientOnly: false, deferred: false, flavors: new Map() });\n        var ref = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            mergeTree: { map: new Map() },\n            context: context,\n        });\n        if (!isReference(ref)) {\n            throw newInvariantError(12, result);\n        }\n        // So far, the store has not been modified, so now it's time to process\n        // context.incomingById and merge those incoming fields into context.store.\n        context.incomingById.forEach(function (_a, dataId) {\n            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;\n            var entityRef = makeReference(dataId);\n            if (mergeTree && mergeTree.map.size) {\n                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n                if (isReference(applied)) {\n                    // Assume References returned by applyMerges have already been merged\n                    // into the store. See makeMergeObjectsFunction in policies.ts for an\n                    // example of how this can happen.\n                    return;\n                }\n                // Otherwise, applyMerges returned a StoreObject, whose fields we should\n                // merge into the store (see store.merge statement below).\n                storeObject = applied;\n            }\n            if (globalThis.__DEV__ !== false && !context.overwrite) {\n                var fieldsWithSelectionSets_1 = Object.create(null);\n                fieldNodeSet.forEach(function (field) {\n                    if (field.selectionSet) {\n                        fieldsWithSelectionSets_1[field.name.value] = true;\n                    }\n                });\n                var hasSelectionSet_1 = function (storeFieldName) {\n                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] ===\n                        true;\n                };\n                var hasMergeFunction_1 = function (storeFieldName) {\n                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\n                };\n                Object.keys(storeObject).forEach(function (storeFieldName) {\n                    // If a merge function was defined for this field, trust that it\n                    // did the right thing about (not) clobbering data. If the field\n                    // has no selection set, it's a scalar field, so it doesn't need\n                    // a merge function (even if it's an object, like JSON data).\n                    if (hasSelectionSet_1(storeFieldName) &&\n                        !hasMergeFunction_1(storeFieldName)) {\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n                    }\n                });\n            }\n            store.merge(dataId, storeObject);\n        });\n        // Any IDs written explicitly to the cache will be retained as\n        // reachable root IDs for garbage collection purposes. Although this\n        // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n        // retainment counts are effectively ignored because cache.gc() always\n        // includes them in its root ID set.\n        store.retain(ref.__ref);\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function (_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, \n        // This object allows processSelectionSet to report useful information\n        // to its callers without explicitly returning that information.\n        mergeTree = _a.mergeTree;\n        var policies = this.cache.policies;\n        // This variable will be repeatedly updated using context.merge to\n        // accumulate all fields that need to be written into the store.\n        var incoming = Object.create(null);\n        // If typename was not passed in, infer it. Note that typename is\n        // always passed in for tricky-to-infer cases such as \"Query\" for\n        // ROOT_QUERY.\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            incoming.__typename = typename;\n        }\n        // This readField function will be passed as context.readField in the\n        // KeyFieldsContext object created within policies.identify (called below).\n        // In addition to reading from the existing context.store (thanks to the\n        // policies.readField(options, context) line at the very bottom), this\n        // version of readField can read from Reference objects that are currently\n        // pending in context.incomingById, which is important whenever keyFields\n        // need to be extracted from a child object that processSelectionSet has\n        // turned into a Reference.\n        var readField = function () {\n            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n            if (isReference(options.from)) {\n                var info = context.incomingById.get(options.from.__ref);\n                if (info) {\n                    var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);\n                    if (result_1 !== void 0) {\n                        return result_1;\n                    }\n                }\n            }\n            return policies.readField(options, context);\n        };\n        var fieldNodeSet = new Set();\n        this.flattenFields(selectionSet, result, \n        // This WriteContext will be the default context value for fields returned\n        // by the flattenFields method, but some fields may be assigned a modified\n        // context, depending on the presence of @client and other directives.\n        context, typename).forEach(function (context, field) {\n            var _a;\n            var resultFieldKey = resultKeyNameFromField(field);\n            var value = result[resultFieldKey];\n            fieldNodeSet.add(field);\n            if (value !== void 0) {\n                var storeFieldName = policies.getStoreFieldName({\n                    typename: typename,\n                    fieldName: field.name.value,\n                    field: field,\n                    variables: context.variables,\n                });\n                var childTree = getChildMergeTree(mergeTree, storeFieldName);\n                var incomingValue = _this.processFieldValue(value, field, \n                // Reset context.clientOnly and context.deferred to their default\n                // values before processing nested selection sets.\n                field.selectionSet ?\n                    getContextFlavor(context, false, false)\n                    : context, childTree);\n                // To determine if this field holds a child object with a merge function\n                // defined in its type policy (see PR #7070), we need to figure out the\n                // child object's __typename.\n                var childTypename = void 0;\n                // The field's value can be an object that has a __typename only if the\n                // field has a selection set. Otherwise incomingValue is scalar.\n                if (field.selectionSet &&\n                    (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n                    childTypename = readField(\"__typename\", incomingValue);\n                }\n                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n                if (merge) {\n                    childTree.info = {\n                        // TODO Check compatibility against any existing childTree.field?\n                        field: field,\n                        typename: typename,\n                        merge: merge,\n                    };\n                }\n                else {\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n                }\n                incoming = context.merge(incoming, (_a = {},\n                    _a[storeFieldName] = incomingValue,\n                    _a));\n            }\n            else if (globalThis.__DEV__ !== false &&\n                !context.clientOnly &&\n                !context.deferred &&\n                !addTypenameToDocument.added(field) &&\n                // If the field has a read function, it may be a synthetic field or\n                // provide a default value, so its absence from the written data should\n                // not be cause for alarm.\n                !policies.getReadFunction(typename, field.name.value)) {\n                globalThis.__DEV__ !== false && invariant.error(13, resultKeyNameFromField(field), result);\n            }\n        });\n        // Identify the result object, even if dataId was already provided,\n        // since we always need keyObject below.\n        try {\n            var _b = policies.identify(result, {\n                typename: typename,\n                selectionSet: selectionSet,\n                fragmentMap: context.fragmentMap,\n                storeObject: incoming,\n                readField: readField,\n            }), id = _b[0], keyObject = _b[1];\n            // If dataId was not provided, fall back to the id just generated by\n            // policies.identify.\n            dataId = dataId || id;\n            // Write any key fields that were used during identification, even if\n            // they were not mentioned in the original query.\n            if (keyObject) {\n                // TODO Reverse the order of the arguments?\n                incoming = context.merge(incoming, keyObject);\n            }\n        }\n        catch (e) {\n            // If dataId was provided, tolerate failure of policies.identify.\n            if (!dataId)\n                throw e;\n        }\n        if (\"string\" === typeof dataId) {\n            var dataRef = makeReference(dataId);\n            // Avoid processing the same entity object using the same selection\n            // set more than once. We use an array instead of a Set since most\n            // entity IDs will be written using only one selection set, so the\n            // size of this array is likely to be very small, meaning indexOf is\n            // likely to be faster than Set.prototype.has.\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            if (sets.indexOf(selectionSet) >= 0)\n                return dataRef;\n            sets.push(selectionSet);\n            // If we're about to write a result object into the store, but we\n            // happen to know that the exact same (===) result object would be\n            // returned if we were to reread the result with the same inputs,\n            // then we can skip the rest of the processSelectionSet work for\n            // this object, and immediately return a Reference to it.\n            if (this.reader &&\n                this.reader.isFresh(result, dataRef, selectionSet, context)) {\n                return dataRef;\n            }\n            var previous_1 = context.incomingById.get(dataId);\n            if (previous_1) {\n                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });\n            }\n            else {\n                context.incomingById.set(dataId, {\n                    storeObject: incoming,\n                    // Save a reference to mergeTree only if it is not empty, because\n                    // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n                    // reused for entirely different parts of the result tree.\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n                    fieldNodeSet: fieldNodeSet,\n                });\n            }\n            return dataRef;\n        }\n        return incoming;\n    };\n    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            // In development, we need to clone scalar values so that they can be\n            // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n            // it's cheaper to store the scalar values directly in the cache.\n            return globalThis.__DEV__ !== false ? cloneDeep(value) : value;\n        }\n        if (isArray(value)) {\n            return value.map(function (item, i) {\n                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n                maybeRecycleChildMergeTree(mergeTree, i);\n                return value;\n            });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            mergeTree: mergeTree,\n        });\n    };\n    // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n    // some additions for tracking @client and @defer directives.\n    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n        if (typename === void 0) { typename = getTypenameFromResult(result, selectionSet, context.fragmentMap); }\n        var fieldMap = new Map();\n        var policies = this.cache.policies;\n        var limitingTrie = new Trie(false); // No need for WeakMap, since limitingTrie does not escape.\n        (function flatten(selectionSet, inheritedContext) {\n            var visitedNode = limitingTrie.lookup(selectionSet, \n            // Because we take inheritedClientOnly and inheritedDeferred into\n            // consideration here (in addition to selectionSet), it's possible for\n            // the same selection set to be flattened more than once, if it appears\n            // in the query with different @client and/or @directive configurations.\n            inheritedContext.clientOnly, inheritedContext.deferred);\n            if (visitedNode.visited)\n                return;\n            visitedNode.visited = true;\n            selectionSet.selections.forEach(function (selection) {\n                if (!shouldInclude(selection, context.variables))\n                    return;\n                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\n                if (\n                // Since the presence of @client or @defer on this field can only\n                // cause clientOnly or deferred to become true, we can skip the\n                // forEach loop if both clientOnly and deferred are already true.\n                !(clientOnly && deferred) &&\n                    isNonEmptyArray(selection.directives)) {\n                    selection.directives.forEach(function (dir) {\n                        var name = dir.name.value;\n                        if (name === \"client\")\n                            clientOnly = true;\n                        if (name === \"defer\") {\n                            var args = argumentsObjectFromField(dir, context.variables);\n                            // The @defer directive takes an optional args.if boolean\n                            // argument, similar to @include(if: boolean). Note that\n                            // @defer(if: false) does not make context.deferred false, but\n                            // instead behaves as if there was no @defer directive.\n                            if (!args || args.if !== false) {\n                                deferred = true;\n                            }\n                            // TODO In the future, we may want to record args.label using\n                            // context.deferred, if a label is specified.\n                        }\n                    });\n                }\n                if (isField(selection)) {\n                    var existing = fieldMap.get(selection);\n                    if (existing) {\n                        // If this field has been visited along another recursive path\n                        // before, the final context should have clientOnly or deferred set\n                        // to true only if *all* paths have the directive (hence the &&).\n                        clientOnly = clientOnly && existing.clientOnly;\n                        deferred = deferred && existing.deferred;\n                    }\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n                }\n                else {\n                    var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                    if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                        throw newInvariantError(14, selection.name.value);\n                    }\n                    if (fragment &&\n                        policies.fragmentMatches(fragment, typename, result, context.variables)) {\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n                    }\n                }\n            });\n        })(selectionSet, context);\n        return fieldMap;\n    };\n    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n        var _a;\n        var _this = this;\n        if (mergeTree.map.size && !isReference(incoming)) {\n            var e_1 = \n            // Items in the same position in different arrays are not\n            // necessarily related to each other, so when incoming is an array\n            // we process its elements as if there was no existing data.\n            (!isArray(incoming) &&\n                // Likewise, existing must be either a Reference or a StoreObject\n                // in order for its fields to be safe to merge with the fields of\n                // the incoming object.\n                (isReference(existing) || storeValueIsStoreObject(existing))) ?\n                existing\n                : void 0;\n            // This narrowing is implied by mergeTree.map.size > 0 and\n            // !isReference(incoming), though TypeScript understandably cannot\n            // hope to infer this type.\n            var i_1 = incoming;\n            // The options.storage objects provided to read and merge functions\n            // are derived from the identity of the parent object plus a\n            // sequence of storeFieldName strings/numbers identifying the nested\n            // field name path of each field value to be merged.\n            if (e_1 && !getStorageArgs) {\n                getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n            }\n            // It's possible that applying merge functions to this subtree will\n            // not change the incoming data, so this variable tracks the fields\n            // that did change, so we can create a new incoming object when (and\n            // only when) at least one incoming field has changed. We use a Map\n            // to preserve the type of numeric keys.\n            var changedFields_1;\n            var getValue_1 = function (from, name) {\n                return (isArray(from) ?\n                    typeof name === \"number\" ?\n                        from[name]\n                        : void 0\n                    : context.store.getFieldValue(from, String(name)));\n            };\n            mergeTree.map.forEach(function (childTree, storeFieldName) {\n                var eVal = getValue_1(e_1, storeFieldName);\n                var iVal = getValue_1(i_1, storeFieldName);\n                // If we have no incoming data, leave any existing data untouched.\n                if (void 0 === iVal)\n                    return;\n                if (getStorageArgs) {\n                    getStorageArgs.push(storeFieldName);\n                }\n                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n                if (aVal !== iVal) {\n                    changedFields_1 = changedFields_1 || new Map();\n                    changedFields_1.set(storeFieldName, aVal);\n                }\n                if (getStorageArgs) {\n                    invariant(getStorageArgs.pop() === storeFieldName);\n                }\n            });\n            if (changedFields_1) {\n                // Shallow clone i so we can add changed fields to it.\n                incoming = (isArray(i_1) ? i_1.slice(0) : __assign({}, i_1));\n                changedFields_1.forEach(function (value, name) {\n                    incoming[name] = value;\n                });\n            }\n        }\n        if (mergeTree.info) {\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n        }\n        return incoming;\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n    var map = _a.map;\n    if (!map.has(name)) {\n        map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\n    }\n    return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n    if (left === right || !right || mergeTreeIsEmpty(right))\n        return left;\n    if (!left || mergeTreeIsEmpty(left))\n        return right;\n    var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n    var needToMergeMaps = left.map.size && right.map.size;\n    var map = needToMergeMaps ? new Map()\n        : left.map.size ? left.map\n            : right.map;\n    var merged = { info: info, map: map };\n    if (needToMergeMaps) {\n        var remainingRightKeys_1 = new Set(right.map.keys());\n        left.map.forEach(function (leftTree, key) {\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n            remainingRightKeys_1.delete(key);\n        });\n        remainingRightKeys_1.forEach(function (key) {\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n        });\n    }\n    return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n    return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n    var map = _a.map;\n    var childTree = map.get(name);\n    if (childTree && mergeTreeIsEmpty(childTree)) {\n        emptyMergeTreePool.push(childTree);\n        map.delete(name);\n    }\n}\nvar warnings = new Set();\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function (objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing)\n        return;\n    var incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    // It's always safe to replace a reference, since it refers to data\n    // safely stored elsewhere.\n    if (isReference(existing))\n        return;\n    // If the values are structurally equivalent, we do not need to worry\n    // about incoming replacing existing.\n    if (equal(existing, incoming))\n        return;\n    // If we're replacing every key of the existing object, then the\n    // existing data would be overwritten even if the objects were\n    // normalized, so warning would not be helpful here.\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n    // Avoid warning more than once for the same type and field name.\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    // Arrays do not have __typename fields, and always need a custom merge\n    // function, even if their elements are normalized entities.\n    if (!isArray(existing) && !isArray(incoming)) {\n        [existing, incoming].forEach(function (child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    globalThis.__DEV__ !== false && invariant.warn(15, fieldName, parentType, childTypenames.length ?\n        \"either ensure all objects of type \" +\n            childTypenames.join(\" and \") +\n            \" have an ID or a custom merge function, or \"\n        : \"\", typeDotName, __assign({}, existing), __assign({}, incoming));\n}\n//# sourceMappingURL=writeToStore.js.map"],"version":3}