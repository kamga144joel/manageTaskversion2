{"version":3,"file":"QueryManager.mjs","sources":["../../../../../../../../../../node_modules/@apollo/client/core/QueryManager.js"],"sourcesContent":["import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { addNonReactiveToNamedFragments, hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, isFullyUnmaskedOperation, removeDirectivesFromDocument, } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform, } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors, } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { QueryInfo, shouldWriteResult, } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = Object.create(null);\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nvar QueryManager = /** @class */ (function () {\n    function QueryManager(options) {\n        var _this = this;\n        this.clientAwareness = {};\n        // All the queries that the QueryManager is currently managing (not\n        // including mutations and subscriptions).\n        this.queries = new Map();\n        // Maps from queryId strings to Promise rejection functions for\n        // currently active queries and fetches.\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.fetchCancelFns = new Map();\n        this.transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] ||\n            2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */);\n        this.queryIdCounter = 1;\n        this.requestIdCounter = 1;\n        this.mutationIdCounter = 1;\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.inFlightLinkObservables = new Trie(false);\n        this.noCacheWarningsByQueryId = new Set();\n        var defaultDocumentTransform = new DocumentTransform(function (document) { return _this.cache.transformDocument(document); }, \n        // Allow the apollo cache to manage its own transform caches\n        { cache: false });\n        this.cache = options.cache;\n        this.link = options.link;\n        this.defaultOptions = options.defaultOptions;\n        this.queryDeduplication = options.queryDeduplication;\n        this.clientAwareness = options.clientAwareness;\n        this.localState = options.localState;\n        this.ssrMode = options.ssrMode;\n        this.assumeImmutableResults = options.assumeImmutableResults;\n        this.dataMasking = options.dataMasking;\n        var documentTransform = options.documentTransform;\n        this.documentTransform =\n            documentTransform ?\n                defaultDocumentTransform\n                    .concat(documentTransform)\n                    // The custom document transform may add new fragment spreads or new\n                    // field selections, so we want to give the cache a chance to run\n                    // again. For example, the InMemoryCache adds __typename to field\n                    // selections and fragments from the fragment registry.\n                    .concat(defaultDocumentTransform)\n                : defaultDocumentTransform;\n        this.defaultContext = options.defaultContext || Object.create(null);\n        if ((this.onBroadcast = options.onBroadcast)) {\n            this.mutationStore = Object.create(null);\n        }\n    }\n    /**\n     * Call this method to terminate any active query processes, making it safe\n     * to dispose of this QueryManager instance.\n     */\n    QueryManager.prototype.stop = function () {\n        var _this = this;\n        this.queries.forEach(function (_info, queryId) {\n            _this.stopQueryNoBroadcast(queryId);\n        });\n        this.cancelPendingFetches(newInvariantError(27));\n    };\n    QueryManager.prototype.cancelPendingFetches = function (error) {\n        this.fetchCancelFns.forEach(function (cancel) { return cancel(error); });\n        this.fetchCancelFns.clear();\n    };\n    QueryManager.prototype.mutate = function (_a) {\n        return __awaiter(this, arguments, void 0, function (_b) {\n            var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\n            var _c, _d;\n            var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || \"network-only\" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || \"none\" : _h, keepRootFields = _b.keepRootFields, context = _b.context;\n            return __generator(this, function (_j) {\n                switch (_j.label) {\n                    case 0:\n                        invariant(mutation, 28);\n                        invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 29);\n                        mutationId = this.generateMutationId();\n                        mutation = this.cache.transformForLink(this.transform(mutation));\n                        hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n                        variables = this.getVariables(mutation, variables);\n                        if (!hasClientExports) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.localState.addExportedVariables(mutation, variables, context)];\n                    case 1:\n                        variables = (_j.sent());\n                        _j.label = 2;\n                    case 2:\n                        mutationStoreValue = this.mutationStore &&\n                            (this.mutationStore[mutationId] = {\n                                mutation: mutation,\n                                variables: variables,\n                                loading: true,\n                                error: null,\n                            });\n                        isOptimistic = optimisticResponse &&\n                            this.markMutationOptimistic(optimisticResponse, {\n                                mutationId: mutationId,\n                                document: mutation,\n                                variables: variables,\n                                fetchPolicy: fetchPolicy,\n                                errorPolicy: errorPolicy,\n                                context: context,\n                                updateQueries: updateQueries,\n                                update: updateWithProxyFn,\n                                keepRootFields: keepRootFields,\n                            });\n                        this.broadcastQueries();\n                        self = this;\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\n                                return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function (result) {\n                                    if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                                        throw new ApolloError({\n                                            graphQLErrors: getGraphQLErrorsFromResult(result),\n                                        });\n                                    }\n                                    if (mutationStoreValue) {\n                                        mutationStoreValue.loading = false;\n                                        mutationStoreValue.error = null;\n                                    }\n                                    var storeResult = __assign({}, result);\n                                    if (typeof refetchQueries === \"function\") {\n                                        refetchQueries = refetchQueries(storeResult);\n                                    }\n                                    if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                                        delete storeResult.errors;\n                                    }\n                                    return self.markMutationResult({\n                                        mutationId: mutationId,\n                                        result: storeResult,\n                                        document: mutation,\n                                        variables: variables,\n                                        fetchPolicy: fetchPolicy,\n                                        errorPolicy: errorPolicy,\n                                        context: context,\n                                        update: updateWithProxyFn,\n                                        updateQueries: updateQueries,\n                                        awaitRefetchQueries: awaitRefetchQueries,\n                                        refetchQueries: refetchQueries,\n                                        removeOptimistic: isOptimistic ? mutationId : void 0,\n                                        onQueryUpdated: onQueryUpdated,\n                                        keepRootFields: keepRootFields,\n                                    });\n                                }).subscribe({\n                                    next: function (storeResult) {\n                                        self.broadcastQueries();\n                                        // Since mutations might receive multiple payloads from the\n                                        // ApolloLink chain (e.g. when used with @defer),\n                                        // we resolve with a SingleExecutionResult or after the final\n                                        // ExecutionPatchResult has arrived and we have assembled the\n                                        // multipart response into a single result.\n                                        if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                                            resolve(__assign(__assign({}, storeResult), { data: self.maskOperation({\n                                                    document: mutation,\n                                                    data: storeResult.data,\n                                                    fetchPolicy: fetchPolicy,\n                                                    id: mutationId,\n                                                }) }));\n                                        }\n                                    },\n                                    error: function (err) {\n                                        if (mutationStoreValue) {\n                                            mutationStoreValue.loading = false;\n                                            mutationStoreValue.error = err;\n                                        }\n                                        if (isOptimistic) {\n                                            self.cache.removeOptimistic(mutationId);\n                                        }\n                                        self.broadcastQueries();\n                                        reject(err instanceof ApolloError ? err : (new ApolloError({\n                                            networkError: err,\n                                        })));\n                                    },\n                                });\n                            })];\n                }\n            });\n        });\n    };\n    QueryManager.prototype.markMutationResult = function (mutation, cache) {\n        var _this = this;\n        if (cache === void 0) { cache = this.cache; }\n        var result = mutation.result;\n        var cacheWrites = [];\n        var skipCache = mutation.fetchPolicy === \"no-cache\";\n        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n            if (!isExecutionPatchIncrementalResult(result)) {\n                cacheWrites.push({\n                    result: result.data,\n                    dataId: \"ROOT_MUTATION\",\n                    query: mutation.document,\n                    variables: mutation.variables,\n                });\n            }\n            if (isExecutionPatchIncrementalResult(result) &&\n                isNonEmptyArray(result.incremental)) {\n                var diff = cache.diff({\n                    id: \"ROOT_MUTATION\",\n                    // The cache complains if passed a mutation where it expects a\n                    // query, so we transform mutations and subscriptions to queries\n                    // (only once, thanks to this.transformCache).\n                    query: this.getDocumentInfo(mutation.document).asQuery,\n                    variables: mutation.variables,\n                    optimistic: false,\n                    returnPartialData: true,\n                });\n                var mergedData = void 0;\n                if (diff.result) {\n                    mergedData = mergeIncrementalData(diff.result, result);\n                }\n                if (typeof mergedData !== \"undefined\") {\n                    // cast the ExecutionPatchResult to FetchResult here since\n                    // ExecutionPatchResult never has `data` when returned from the server\n                    result.data = mergedData;\n                    cacheWrites.push({\n                        result: mergedData,\n                        dataId: \"ROOT_MUTATION\",\n                        query: mutation.document,\n                        variables: mutation.variables,\n                    });\n                }\n            }\n            var updateQueries_1 = mutation.updateQueries;\n            if (updateQueries_1) {\n                this.queries.forEach(function (_a, queryId) {\n                    var observableQuery = _a.observableQuery;\n                    var queryName = observableQuery && observableQuery.queryName;\n                    if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n                        return;\n                    }\n                    var updater = updateQueries_1[queryName];\n                    var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;\n                    // Read the current query result from the store.\n                    var _c = cache.diff({\n                        query: document,\n                        variables: variables,\n                        returnPartialData: true,\n                        optimistic: false,\n                    }), currentQueryResult = _c.result, complete = _c.complete;\n                    if (complete && currentQueryResult) {\n                        // Run our reducer using the current query result and the mutation result.\n                        var nextQueryResult = updater(currentQueryResult, {\n                            mutationResult: result,\n                            queryName: (document && getOperationName(document)) || void 0,\n                            queryVariables: variables,\n                        });\n                        // Write the modified result back into the store if we got a new result.\n                        if (nextQueryResult) {\n                            cacheWrites.push({\n                                result: nextQueryResult,\n                                dataId: \"ROOT_QUERY\",\n                                query: document,\n                                variables: variables,\n                            });\n                        }\n                    }\n                });\n            }\n        }\n        if (cacheWrites.length > 0 ||\n            (mutation.refetchQueries || \"\").length > 0 ||\n            mutation.update ||\n            mutation.onQueryUpdated ||\n            mutation.removeOptimistic) {\n            var results_1 = [];\n            this.refetchQueries({\n                updateCache: function (cache) {\n                    if (!skipCache) {\n                        cacheWrites.forEach(function (write) { return cache.write(write); });\n                    }\n                    // If the mutation has some writes associated with it then we need to\n                    // apply those writes to the store by running this reducer again with\n                    // a write action.\n                    var update = mutation.update;\n                    // Determine whether result is a SingleExecutionResult,\n                    // or the final ExecutionPatchResult.\n                    var isFinalResult = !isExecutionPatchResult(result) ||\n                        (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n                    if (update) {\n                        if (!skipCache) {\n                            // Re-read the ROOT_MUTATION data we just wrote into the cache\n                            // (the first cache.write call in the cacheWrites.forEach loop\n                            // above), so field read functions have a chance to run for\n                            // fields within mutation result objects.\n                            var diff = cache.diff({\n                                id: \"ROOT_MUTATION\",\n                                // The cache complains if passed a mutation where it expects a\n                                // query, so we transform mutations and subscriptions to queries\n                                // (only once, thanks to this.transformCache).\n                                query: _this.getDocumentInfo(mutation.document).asQuery,\n                                variables: mutation.variables,\n                                optimistic: false,\n                                returnPartialData: true,\n                            });\n                            if (diff.complete) {\n                                result = __assign(__assign({}, result), { data: diff.result });\n                                if (\"incremental\" in result) {\n                                    delete result.incremental;\n                                }\n                                if (\"hasNext\" in result) {\n                                    delete result.hasNext;\n                                }\n                            }\n                        }\n                        // If we've received the whole response,\n                        // either a SingleExecutionResult or the final ExecutionPatchResult,\n                        // call the update function.\n                        if (isFinalResult) {\n                            update(cache, result, {\n                                context: mutation.context,\n                                variables: mutation.variables,\n                            });\n                        }\n                    }\n                    // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n                    // shallow to allow rolling back optimistic evictions.\n                    if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n                        cache.modify({\n                            id: \"ROOT_MUTATION\",\n                            fields: function (value, _a) {\n                                var fieldName = _a.fieldName, DELETE = _a.DELETE;\n                                return fieldName === \"__typename\" ? value : DELETE;\n                            },\n                        });\n                    }\n                },\n                include: mutation.refetchQueries,\n                // Write the final mutation.result to the root layer of the cache.\n                optimistic: false,\n                // Remove the corresponding optimistic layer at the same time as we\n                // write the final non-optimistic result.\n                removeOptimistic: mutation.removeOptimistic,\n                // Let the caller of client.mutate optionally determine the refetching\n                // behavior for watched queries after the mutation.update function runs.\n                // If no onQueryUpdated function was provided for this mutation, pass\n                // null instead of undefined to disable the default refetching behavior.\n                onQueryUpdated: mutation.onQueryUpdated || null,\n            }).forEach(function (result) { return results_1.push(result); });\n            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n                // Returning a promise here makes the mutation await that promise, so we\n                // include results in that promise's work if awaitRefetchQueries or an\n                // onQueryUpdated function was specified.\n                return Promise.all(results_1).then(function () { return result; });\n            }\n        }\n        return Promise.resolve(result);\n    };\n    QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n        var _this = this;\n        var data = typeof optimisticResponse === \"function\" ?\n            optimisticResponse(mutation.variables, { IGNORE: IGNORE })\n            : optimisticResponse;\n        if (data === IGNORE) {\n            return false;\n        }\n        this.cache.recordOptimisticTransaction(function (cache) {\n            try {\n                _this.markMutationResult(__assign(__assign({}, mutation), { result: { data: data } }), cache);\n            }\n            catch (error) {\n                globalThis.__DEV__ !== false && invariant.error(error);\n            }\n        }, mutation.mutationId);\n        return true;\n    };\n    QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n        return this.fetchConcastWithInfo(this.getOrCreateQuery(queryId), options, networkStatus).concast.promise;\n    };\n    QueryManager.prototype.getQueryStore = function () {\n        var store = Object.create(null);\n        this.queries.forEach(function (info, queryId) {\n            store[queryId] = {\n                variables: info.variables,\n                networkStatus: info.networkStatus,\n                networkError: info.networkError,\n                graphQLErrors: info.graphQLErrors,\n            };\n        });\n        return store;\n    };\n    QueryManager.prototype.resetErrors = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo) {\n            queryInfo.networkError = undefined;\n            queryInfo.graphQLErrors = [];\n        }\n    };\n    QueryManager.prototype.transform = function (document) {\n        return this.documentTransform.transformDocument(document);\n    };\n    QueryManager.prototype.getDocumentInfo = function (document) {\n        var transformCache = this.transformCache;\n        if (!transformCache.has(document)) {\n            var cacheEntry = {\n                // TODO These three calls (hasClientExports, shouldForceResolvers, and\n                // usesNonreactiveDirective) are performing independent full traversals\n                // of the transformed document. We should consider merging these\n                // traversals into a single pass in the future, though the work is\n                // cached after the first time.\n                hasClientExports: hasClientExports(document),\n                hasForcedResolvers: this.localState.shouldForceResolvers(document),\n                hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n                nonReactiveQuery: addNonReactiveToNamedFragments(document),\n                clientQuery: this.localState.clientQuery(document),\n                serverQuery: removeDirectivesFromDocument([\n                    { name: \"client\", remove: true },\n                    { name: \"connection\" },\n                    { name: \"nonreactive\" },\n                    { name: \"unmask\" },\n                ], document),\n                defaultVars: getDefaultValues(getOperationDefinition(document)),\n                // Transform any mutation or subscription operations to query operations\n                // so we can read/write them from/to the cache.\n                asQuery: __assign(__assign({}, document), { definitions: document.definitions.map(function (def) {\n                        if (def.kind === \"OperationDefinition\" &&\n                            def.operation !== \"query\") {\n                            return __assign(__assign({}, def), { operation: \"query\" });\n                        }\n                        return def;\n                    }) }),\n            };\n            transformCache.set(document, cacheEntry);\n        }\n        return transformCache.get(document);\n    };\n    QueryManager.prototype.getVariables = function (document, variables) {\n        return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n    };\n    QueryManager.prototype.watchQuery = function (options) {\n        var query = this.transform(options.query);\n        // assign variable default values if supplied\n        // NOTE: We don't modify options.query here with the transformed query to\n        // ensure observable.options.query is set to the raw untransformed query.\n        options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });\n        if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n            options.notifyOnNetworkStatusChange = false;\n        }\n        var queryInfo = new QueryInfo(this);\n        var observable = new ObservableQuery({\n            queryManager: this,\n            queryInfo: queryInfo,\n            options: options,\n        });\n        observable[\"lastQuery\"] = query;\n        if (!ObservableQuery[\"inactiveOnCreation\"].getValue()) {\n            this.queries.set(observable.queryId, queryInfo);\n        }\n        // We give queryInfo the transformed query to ensure the first cache diff\n        // uses the transformed query instead of the raw query\n        queryInfo.init({\n            document: query,\n            observableQuery: observable,\n            variables: observable.variables,\n        });\n        return observable;\n    };\n    QueryManager.prototype.query = function (options, queryId) {\n        var _this = this;\n        if (queryId === void 0) { queryId = this.generateQueryId(); }\n        invariant(options.query, 30);\n        invariant(options.query.kind === \"Document\", 31);\n        invariant(!options.returnPartialData, 32);\n        invariant(!options.pollInterval, 33);\n        var query = this.transform(options.query);\n        return this.fetchQuery(queryId, __assign(__assign({}, options), { query: query }))\n            .then(function (result) {\n            return result && __assign(__assign({}, result), { data: _this.maskOperation({\n                    document: query,\n                    data: result.data,\n                    fetchPolicy: options.fetchPolicy,\n                    id: queryId,\n                }) });\n        })\n            .finally(function () { return _this.stopQuery(queryId); });\n    };\n    QueryManager.prototype.generateQueryId = function () {\n        return String(this.queryIdCounter++);\n    };\n    QueryManager.prototype.generateRequestId = function () {\n        return this.requestIdCounter++;\n    };\n    QueryManager.prototype.generateMutationId = function () {\n        return String(this.mutationIdCounter++);\n    };\n    QueryManager.prototype.stopQueryInStore = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo)\n            queryInfo.stop();\n    };\n    QueryManager.prototype.clearStore = function (options) {\n        if (options === void 0) { options = {\n            discardWatches: true,\n        }; }\n        // Before we have sent the reset action to the store, we can no longer\n        // rely on the results returned by in-flight requests since these may\n        // depend on values that previously existed in the data portion of the\n        // store. So, we cancel the promises and observers that we have issued\n        // so far and not yet resolved (in the case of queries).\n        this.cancelPendingFetches(newInvariantError(34));\n        this.queries.forEach(function (queryInfo) {\n            if (queryInfo.observableQuery) {\n                // Set loading to true so listeners don't trigger unless they want\n                // results with partial data.\n                queryInfo.networkStatus = NetworkStatus.loading;\n            }\n            else {\n                queryInfo.stop();\n            }\n        });\n        if (this.mutationStore) {\n            this.mutationStore = Object.create(null);\n        }\n        // begin removing data from the store\n        return this.cache.reset(options);\n    };\n    QueryManager.prototype.getObservableQueries = function (include) {\n        var _this = this;\n        if (include === void 0) { include = \"active\"; }\n        var queries = new Map();\n        var queryNames = new Map();\n        var queryNamesAndQueryStrings = new Map();\n        var legacyQueryOptions = new Set();\n        if (Array.isArray(include)) {\n            include.forEach(function (desc) {\n                if (typeof desc === \"string\") {\n                    queryNames.set(desc, desc);\n                    queryNamesAndQueryStrings.set(desc, false);\n                }\n                else if (isDocumentNode(desc)) {\n                    var queryString = print(_this.transform(desc));\n                    queryNames.set(queryString, getOperationName(desc));\n                    queryNamesAndQueryStrings.set(queryString, false);\n                }\n                else if (isNonNullObject(desc) && desc.query) {\n                    legacyQueryOptions.add(desc);\n                }\n            });\n        }\n        this.queries.forEach(function (_a, queryId) {\n            var oq = _a.observableQuery, document = _a.document;\n            if (oq) {\n                if (include === \"all\") {\n                    queries.set(queryId, oq);\n                    return;\n                }\n                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;\n                if (fetchPolicy === \"standby\" ||\n                    (include === \"active\" && !oq.hasObservers())) {\n                    return;\n                }\n                if (include === \"active\" ||\n                    (queryName && queryNamesAndQueryStrings.has(queryName)) ||\n                    (document && queryNamesAndQueryStrings.has(print(document)))) {\n                    queries.set(queryId, oq);\n                    if (queryName)\n                        queryNamesAndQueryStrings.set(queryName, true);\n                    if (document)\n                        queryNamesAndQueryStrings.set(print(document), true);\n                }\n            }\n        });\n        if (legacyQueryOptions.size) {\n            legacyQueryOptions.forEach(function (options) {\n                // We will be issuing a fresh network request for this query, so we\n                // pre-allocate a new query ID here, using a special prefix to enable\n                // cleaning up these temporary queries later, after fetching.\n                var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n                var queryInfo = _this.getOrCreateQuery(queryId).init({\n                    document: options.query,\n                    variables: options.variables,\n                });\n                var oq = new ObservableQuery({\n                    queryManager: _this,\n                    queryInfo: queryInfo,\n                    options: __assign(__assign({}, options), { fetchPolicy: \"network-only\" }),\n                });\n                invariant(oq.queryId === queryId);\n                queryInfo.setObservableQuery(oq);\n                queries.set(queryId, oq);\n            });\n        }\n        if (globalThis.__DEV__ !== false && queryNamesAndQueryStrings.size) {\n            queryNamesAndQueryStrings.forEach(function (included, nameOrQueryString) {\n                if (!included) {\n                    var queryName = queryNames.get(nameOrQueryString);\n                    if (queryName) {\n                        globalThis.__DEV__ !== false && invariant.warn(35, queryName);\n                    }\n                    else {\n                        globalThis.__DEV__ !== false && invariant.warn(36);\n                    }\n                }\n            });\n        }\n        return queries;\n    };\n    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n        var _this = this;\n        if (includeStandby === void 0) { includeStandby = false; }\n        var observableQueryPromises = [];\n        this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n            var fetchPolicy = observableQuery.options.fetchPolicy;\n            observableQuery.resetLastResults();\n            if (includeStandby ||\n                (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")) {\n                observableQueryPromises.push(observableQuery.refetch());\n            }\n            (_this.queries.get(queryId) || observableQuery[\"queryInfo\"]).setDiff(null);\n        });\n        this.broadcastQueries();\n        return Promise.all(observableQueryPromises);\n    };\n    QueryManager.prototype.startGraphQLSubscription = function (options) {\n        var _this = this;\n        var query = options.query, variables = options.variables;\n        var fetchPolicy = options.fetchPolicy, _a = options.errorPolicy, errorPolicy = _a === void 0 ? \"none\" : _a, _b = options.context, context = _b === void 0 ? {} : _b, _c = options.extensions, extensions = _c === void 0 ? {} : _c;\n        query = this.transform(query);\n        variables = this.getVariables(query, variables);\n        var makeObservable = function (variables) {\n            return _this.getObservableFromLink(query, context, variables, extensions).map(function (result) {\n                if (fetchPolicy !== \"no-cache\") {\n                    // the subscription interface should handle not sending us results we no longer subscribe to.\n                    // XXX I don't think we ever send in an object with errors, but we might in the future...\n                    if (shouldWriteResult(result, errorPolicy)) {\n                        _this.cache.write({\n                            query: query,\n                            result: result.data,\n                            dataId: \"ROOT_SUBSCRIPTION\",\n                            variables: variables,\n                        });\n                    }\n                    _this.broadcastQueries();\n                }\n                var hasErrors = graphQLResultHasError(result);\n                var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n                if (hasErrors || hasProtocolErrors) {\n                    var errors = {};\n                    if (hasErrors) {\n                        errors.graphQLErrors = result.errors;\n                    }\n                    if (hasProtocolErrors) {\n                        errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n                    }\n                    // `errorPolicy` is a mechanism for handling GraphQL errors, according\n                    // to our documentation, so we throw protocol errors regardless of the\n                    // set error policy.\n                    if (errorPolicy === \"none\" || hasProtocolErrors) {\n                        throw new ApolloError(errors);\n                    }\n                }\n                if (errorPolicy === \"ignore\") {\n                    delete result.errors;\n                }\n                return result;\n            });\n        };\n        if (this.getDocumentInfo(query).hasClientExports) {\n            var observablePromise_1 = this.localState\n                .addExportedVariables(query, variables, context)\n                .then(makeObservable);\n            return new Observable(function (observer) {\n                var sub = null;\n                observablePromise_1.then(function (observable) { return (sub = observable.subscribe(observer)); }, observer.error);\n                return function () { return sub && sub.unsubscribe(); };\n            });\n        }\n        return makeObservable(variables);\n    };\n    QueryManager.prototype.stopQuery = function (queryId) {\n        this.stopQueryNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.removeQuery(queryId);\n    };\n    QueryManager.prototype.removeQuery = function (queryId) {\n        var _a;\n        // teardown all links\n        // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n        // that each add their reject functions to fetchCancelFns.\n        // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n        // The same queryId could have two rejection fns for two promises\n        this.fetchCancelFns.delete(queryId);\n        if (this.queries.has(queryId)) {\n            (_a = this.queries.get(queryId)) === null || _a === void 0 ? void 0 : _a.stop();\n            this.queries.delete(queryId);\n        }\n    };\n    QueryManager.prototype.broadcastQueries = function () {\n        if (this.onBroadcast)\n            this.onBroadcast();\n        this.queries.forEach(function (info) { var _a; return (_a = info.observableQuery) === null || _a === void 0 ? void 0 : _a[\"notify\"](); });\n    };\n    QueryManager.prototype.getLocalState = function () {\n        return this.localState;\n    };\n    QueryManager.prototype.getObservableFromLink = function (query, context, variables, extensions, \n    // Prefer context.queryDeduplication if specified.\n    deduplication) {\n        var _this = this;\n        var _a;\n        if (deduplication === void 0) { deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication; }\n        var observable;\n        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;\n        if (serverQuery) {\n            var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;\n            var operation = {\n                query: serverQuery,\n                variables: variables,\n                operationName: getOperationName(serverQuery) || void 0,\n                context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),\n                extensions: extensions,\n            };\n            context = operation.context;\n            if (deduplication) {\n                var printedServerQuery_1 = print(serverQuery);\n                var varJson_1 = canonicalStringify(variables);\n                var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n                observable = entry.observable;\n                if (!observable) {\n                    var concast_1 = new Concast([\n                        execute(link, operation),\n                    ]);\n                    observable = entry.observable = concast_1;\n                    concast_1.beforeNext(function cb(method, arg) {\n                        if (method === \"next\" && \"hasNext\" in arg && arg.hasNext) {\n                            concast_1.beforeNext(cb);\n                        }\n                        else {\n                            inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n                        }\n                    });\n                }\n            }\n            else {\n                observable = new Concast([\n                    execute(link, operation),\n                ]);\n            }\n        }\n        else {\n            observable = new Concast([Observable.of({ data: {} })]);\n            context = this.prepareContext(context);\n        }\n        if (clientQuery) {\n            observable = asyncMap(observable, function (result) {\n                return _this.localState.runResolvers({\n                    document: clientQuery,\n                    remoteResult: result,\n                    context: context,\n                    variables: variables,\n                });\n            });\n        }\n        return observable;\n    };\n    QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n        var requestId = (queryInfo.lastRequestId = this.generateRequestId());\n        // Performing transformForLink here gives this.cache a chance to fill in\n        // missing fragment definitions (for example) before sending this document\n        // through the link chain.\n        var linkDocument = this.cache.transformForLink(options.query);\n        return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n            var graphQLErrors = getGraphQLErrorsFromResult(result);\n            var hasErrors = graphQLErrors.length > 0;\n            var errorPolicy = options.errorPolicy;\n            // If we interrupted this request by calling getResultsFromLink again\n            // with the same QueryInfo object, we ignore the old results.\n            if (requestId >= queryInfo.lastRequestId) {\n                if (hasErrors && errorPolicy === \"none\") {\n                    // Throwing here effectively calls observer.error.\n                    throw queryInfo.markError(new ApolloError({\n                        graphQLErrors: graphQLErrors,\n                    }));\n                }\n                // Use linkDocument rather than queryInfo.document so the\n                // operation/fragments used to write the result are the same as the\n                // ones used to obtain it from the link.\n                queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n                queryInfo.markReady();\n            }\n            var aqr = {\n                data: result.data,\n                loading: false,\n                networkStatus: NetworkStatus.ready,\n            };\n            // In the case we start multiple network requests simulatenously, we\n            // want to ensure we properly set `data` if we're reporting on an old\n            // result which will not be caught by the conditional above that ends up\n            // throwing the markError result.\n            if (hasErrors && errorPolicy === \"none\") {\n                aqr.data = void 0;\n            }\n            if (hasErrors && errorPolicy !== \"ignore\") {\n                aqr.errors = graphQLErrors;\n                aqr.networkStatus = NetworkStatus.error;\n            }\n            return aqr;\n        }, function (networkError) {\n            var error = isApolloError(networkError) ? networkError : (new ApolloError({ networkError: networkError }));\n            // Avoid storing errors from older interrupted queries.\n            if (requestId >= queryInfo.lastRequestId) {\n                queryInfo.markError(error);\n            }\n            throw error;\n        });\n    };\n    QueryManager.prototype.fetchConcastWithInfo = function (queryInfo, options, \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus, query) {\n        var _this = this;\n        if (networkStatus === void 0) { networkStatus = NetworkStatus.loading; }\n        if (query === void 0) { query = options.query; }\n        var variables = this.getVariables(query, options.variables);\n        var defaults = this.defaultOptions.watchQuery;\n        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? (defaults && defaults.fetchPolicy) || \"cache-first\" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? (defaults && defaults.errorPolicy) || \"none\" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;\n        var normalized = Object.assign({}, options, {\n            query: query,\n            variables: variables,\n            fetchPolicy: fetchPolicy,\n            errorPolicy: errorPolicy,\n            returnPartialData: returnPartialData,\n            notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n            context: context,\n        });\n        var fromVariables = function (variables) {\n            // Since normalized is always a fresh copy of options, it's safe to\n            // modify its properties here, rather than creating yet another new\n            // WatchQueryOptions object.\n            normalized.variables = variables;\n            var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n            if (\n            // If we're in standby, postpone advancing options.fetchPolicy using\n            // applyNextFetchPolicy.\n            normalized.fetchPolicy !== \"standby\" &&\n                // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n                // this is another way to detect when nothing was done/fetched.\n                sourcesWithInfo.sources.length > 0 &&\n                queryInfo.observableQuery) {\n                queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n            }\n            return sourcesWithInfo;\n        };\n        // This cancel function needs to be set before the concast is created,\n        // in case concast creation synchronously cancels the request.\n        var cleanupCancelFn = function () { return _this.fetchCancelFns.delete(queryInfo.queryId); };\n        this.fetchCancelFns.set(queryInfo.queryId, function (reason) {\n            cleanupCancelFn();\n            // This delay ensures the concast variable has been initialized.\n            setTimeout(function () { return concast.cancel(reason); });\n        });\n        var concast, containsDataFromLink;\n        // If the query has @export(as: ...) directives, then we need to\n        // process those directives asynchronously. When there are no\n        // @export directives (the common case), we deliberately avoid\n        // wrapping the result of this.fetchQueryByPolicy in a Promise,\n        // since the timing of result delivery is (unfortunately) important\n        // for backwards compatibility. TODO This code could be simpler if\n        // we deprecated and removed LocalState.\n        if (this.getDocumentInfo(normalized.query).hasClientExports) {\n            concast = new Concast(this.localState\n                .addExportedVariables(normalized.query, normalized.variables, normalized.context)\n                .then(fromVariables)\n                .then(function (sourcesWithInfo) { return sourcesWithInfo.sources; }));\n            // there is just no way we can synchronously get the *right* value here,\n            // so we will assume `true`, which is the behaviour before the bug fix in\n            // #10597. This means that bug is not fixed in that case, and is probably\n            // un-fixable with reasonable effort for the edge case of @export as\n            // directives.\n            containsDataFromLink = true;\n        }\n        else {\n            var sourcesWithInfo = fromVariables(normalized.variables);\n            containsDataFromLink = sourcesWithInfo.fromLink;\n            concast = new Concast(sourcesWithInfo.sources);\n        }\n        concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n        return {\n            concast: concast,\n            fromLink: containsDataFromLink,\n        };\n    };\n    QueryManager.prototype.refetchQueries = function (_a) {\n        var _this = this;\n        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;\n        var includedQueriesById = new Map();\n        if (include) {\n            this.getObservableQueries(include).forEach(function (oq, queryId) {\n                includedQueriesById.set(queryId, {\n                    oq: oq,\n                    lastDiff: (_this.queries.get(queryId) || oq[\"queryInfo\"]).getDiff(),\n                });\n            });\n        }\n        var results = new Map();\n        if (updateCache) {\n            this.cache.batch({\n                update: updateCache,\n                // Since you can perform any combination of cache reads and/or writes in\n                // the cache.batch update function, its optimistic option can be either\n                // a boolean or a string, representing three distinct modes of\n                // operation:\n                //\n                // * false: read/write only the root layer\n                // * true: read/write the topmost layer\n                // * string: read/write a fresh optimistic layer with that ID string\n                //\n                // When typeof optimistic === \"string\", a new optimistic layer will be\n                // temporarily created within cache.batch with that string as its ID. If\n                // we then pass that same string as the removeOptimistic option, we can\n                // make cache.batch immediately remove the optimistic layer after\n                // running the updateCache function, triggering only one broadcast.\n                //\n                // However, the refetchQueries method accepts only true or false for its\n                // optimistic option (not string). We interpret true to mean a temporary\n                // optimistic layer should be created, to allow efficiently rolling back\n                // the effect of the updateCache function, which involves passing a\n                // string instead of true as the optimistic option to cache.batch, when\n                // refetchQueries receives optimistic: true.\n                //\n                // In other words, we are deliberately not supporting the use case of\n                // writing to an *existing* optimistic layer (using the refetchQueries\n                // updateCache function), since that would potentially interfere with\n                // other optimistic updates in progress. Instead, you can read/write\n                // only the root layer by passing optimistic: false to refetchQueries,\n                // or you can read/write a brand new optimistic layer that will be\n                // automatically removed by passing optimistic: true.\n                optimistic: (optimistic && removeOptimistic) || false,\n                // The removeOptimistic option can also be provided by itself, even if\n                // optimistic === false, to remove some previously-added optimistic\n                // layer safely and efficiently, like we do in markMutationResult.\n                //\n                // If an explicit removeOptimistic string is provided with optimistic:\n                // true, the removeOptimistic string will determine the ID of the\n                // temporary optimistic layer, in case that ever matters.\n                removeOptimistic: removeOptimistic,\n                onWatchUpdated: function (watch, diff, lastDiff) {\n                    var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n                    if (oq) {\n                        if (onQueryUpdated) {\n                            // Since we're about to handle this query now, remove it from\n                            // includedQueriesById, in case it was added earlier because of\n                            // options.include.\n                            includedQueriesById.delete(oq.queryId);\n                            var result = onQueryUpdated(oq, diff, lastDiff);\n                            if (result === true) {\n                                // The onQueryUpdated function requested the default refetching\n                                // behavior by returning true.\n                                result = oq.refetch();\n                            }\n                            // Record the result in the results Map, as long as onQueryUpdated\n                            // did not return false to skip/ignore this result.\n                            if (result !== false) {\n                                results.set(oq, result);\n                            }\n                            // Allow the default cache broadcast to happen, except when\n                            // onQueryUpdated returns false.\n                            return result;\n                        }\n                        if (onQueryUpdated !== null) {\n                            // If we don't have an onQueryUpdated function, and onQueryUpdated\n                            // was not disabled by passing null, make sure this query is\n                            // \"included\" like any other options.include-specified query.\n                            includedQueriesById.set(oq.queryId, { oq: oq, lastDiff: lastDiff, diff: diff });\n                        }\n                    }\n                },\n            });\n        }\n        if (includedQueriesById.size) {\n            includedQueriesById.forEach(function (_a, queryId) {\n                var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;\n                var result;\n                // If onQueryUpdated is provided, we want to use it for all included\n                // queries, even the QueryOptions ones.\n                if (onQueryUpdated) {\n                    if (!diff) {\n                        diff = _this.cache.diff(oq[\"queryInfo\"][\"getDiffOptions\"]());\n                    }\n                    result = onQueryUpdated(oq, diff, lastDiff);\n                }\n                // Otherwise, we fall back to refetching.\n                if (!onQueryUpdated || result === true) {\n                    result = oq.refetch();\n                }\n                if (result !== false) {\n                    results.set(oq, result);\n                }\n                if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n                    _this.stopQueryNoBroadcast(queryId);\n                }\n            });\n        }\n        if (removeOptimistic) {\n            // In case no updateCache callback was provided (so cache.batch was not\n            // called above, and thus did not already remove the optimistic layer),\n            // remove it here. Since this is a no-op when the layer has already been\n            // removed, we do it even if we called cache.batch above, since it's\n            // possible this.cache is an instance of some ApolloCache subclass other\n            // than InMemoryCache, and does not fully support the removeOptimistic\n            // option for cache.batch.\n            this.cache.removeOptimistic(removeOptimistic);\n        }\n        return results;\n    };\n    QueryManager.prototype.maskOperation = function (options) {\n        var _a, _b, _c;\n        var document = options.document, data = options.data;\n        if (globalThis.__DEV__ !== false) {\n            var fetchPolicy = options.fetchPolicy, id = options.id;\n            var operationType = (_a = getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation;\n            var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : \"o\") + id;\n            if (this.dataMasking &&\n                fetchPolicy === \"no-cache\" &&\n                !isFullyUnmaskedOperation(document) &&\n                !this.noCacheWarningsByQueryId.has(operationId)) {\n                this.noCacheWarningsByQueryId.add(operationId);\n                globalThis.__DEV__ !== false && invariant.warn(\n                    37,\n                    (_c = getOperationName(document)) !== null && _c !== void 0 ? _c : \"Unnamed \".concat(operationType !== null && operationType !== void 0 ? operationType : \"operation\")\n                );\n            }\n        }\n        return (this.dataMasking ?\n            maskOperation(data, document, this.cache)\n            : data);\n    };\n    QueryManager.prototype.maskFragment = function (options) {\n        var data = options.data, fragment = options.fragment, fragmentName = options.fragmentName;\n        return this.dataMasking ?\n            maskFragment(data, fragment, this.cache, fragmentName)\n            : data;\n    };\n    QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus) {\n        var _this = this;\n        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n        var oldNetworkStatus = queryInfo.networkStatus;\n        queryInfo.init({\n            document: query,\n            variables: variables,\n            networkStatus: networkStatus,\n        });\n        var readCache = function () { return queryInfo.getDiff(); };\n        var resultsFromCache = function (diff, networkStatus) {\n            if (networkStatus === void 0) { networkStatus = queryInfo.networkStatus || NetworkStatus.loading; }\n            var data = diff.result;\n            if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n                logMissingFieldErrors(diff.missing);\n            }\n            var fromData = function (data) {\n                return Observable.of(__assign({ data: data, loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus }, (diff.complete ? null : { partial: true })));\n            };\n            if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n                return _this.localState\n                    .runResolvers({\n                    document: query,\n                    remoteResult: { data: data },\n                    context: context,\n                    variables: variables,\n                    onlyRunForcedResolvers: true,\n                })\n                    .then(function (resolved) { return fromData(resolved.data || void 0); });\n            }\n            // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n            // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n            // data was incorrectly returned from the cache on refetch:\n            // if diff.missing exists, we should not return cache data.\n            if (errorPolicy === \"none\" &&\n                networkStatus === NetworkStatus.refetch &&\n                Array.isArray(diff.missing)) {\n                return fromData(void 0);\n            }\n            return fromData(data);\n        };\n        var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n            // Watched queries must opt into overwriting existing data on refetch,\n            // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n            : (networkStatus === NetworkStatus.refetch &&\n                refetchWritePolicy !== \"merge\") ?\n                1 /* CacheWriteBehavior.OVERWRITE */\n                : 2 /* CacheWriteBehavior.MERGE */;\n        var resultsFromLink = function () {\n            return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n                query: query,\n                variables: variables,\n                context: context,\n                fetchPolicy: fetchPolicy,\n                errorPolicy: errorPolicy,\n            });\n        };\n        var shouldNotify = notifyOnNetworkStatusChange &&\n            typeof oldNetworkStatus === \"number\" &&\n            oldNetworkStatus !== networkStatus &&\n            isNetworkRequestInFlight(networkStatus);\n        switch (fetchPolicy) {\n            default:\n            case \"cache-first\": {\n                var diff = readCache();\n                if (diff.complete) {\n                    return {\n                        fromLink: false,\n                        sources: [resultsFromCache(diff, queryInfo.markReady())],\n                    };\n                }\n                if (returnPartialData || shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(diff), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            }\n            case \"cache-and-network\": {\n                var diff = readCache();\n                if (diff.complete || returnPartialData || shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(diff), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            }\n            case \"cache-only\":\n                return {\n                    fromLink: false,\n                    sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n                };\n            case \"network-only\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(readCache()), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            case \"no-cache\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        // Note that queryInfo.getDiff() for no-cache queries does not call\n                        // cache.diff, but instead returns a { complete: false } stub result\n                        // when there is no queryInfo.diff already defined.\n                        sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            case \"standby\":\n                return { fromLink: false, sources: [] };\n        }\n    };\n    QueryManager.prototype.getOrCreateQuery = function (queryId) {\n        if (queryId && !this.queries.has(queryId)) {\n            this.queries.set(queryId, new QueryInfo(this, queryId));\n        }\n        return this.queries.get(queryId);\n    };\n    QueryManager.prototype.prepareContext = function (context) {\n        if (context === void 0) { context = {}; }\n        var newContext = this.localState.prepareContext(context);\n        return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });\n    };\n    return QueryManager;\n}());\nexport { QueryManager };\n//# sourceMappingURL=QueryManager.js.map"],"names":["QueryManager","hasClientExports","cache","diff","result","variables","sourcesWithInfo","_a","networkStatus","data"],"mappings":"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","x_google_ignoreList":[0]}