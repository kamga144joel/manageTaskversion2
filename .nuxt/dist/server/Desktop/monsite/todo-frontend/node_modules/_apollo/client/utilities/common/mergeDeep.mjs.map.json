{"file":"mergeDeep.mjs","mappings":";;AAEA,IAAI,iBAAiB,OAAO,UAAU;AAC/B,SAAS,YAAY;AACxB,MAAI,UAAU,CAAE;AAChB,WAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,YAAQ,EAAE,IAAI,UAAU,EAAE;AAAA,EAClC;AACI,SAAO,eAAe,OAAO;AACjC;AAOO,SAAS,eAAe,SAAS;AACpC,MAAI,SAAS,QAAQ,CAAC,KAAK,CAAE;AAC7B,MAAI,QAAQ,QAAQ;AACpB,MAAI,QAAQ,GAAG;AACX,QAAI,SAAS,IAAI,WAAY;AAC7B,aAAS,IAAI,GAAG,IAAI,OAAO,EAAE,GAAG;AAC5B,eAAS,OAAO,MAAM,QAAQ,QAAQ,CAAC,CAAC;AAAA,IACpD;AAAA,EACA;AACI,SAAO;AACX;AACA,IAAI,oBAAoB,SAAU,QAAQ,QAAQ,UAAU;AACxD,SAAO,KAAK,MAAM,OAAO,QAAQ,GAAG,OAAO,QAAQ,CAAC;AACxD;AACG,IAAC;AAAA;AAAA,EAA4B,WAAY;AACxC,aAASA,YAAW,YAAY;AAC5B,UAAI,eAAe,QAAQ;AAAE,qBAAa;AAAA,MAAkB;AAC5D,WAAK,aAAa;AAClB,WAAK,WAAW;AAChB,WAAK,aAAa,oBAAI,IAAK;AAAA,IACnC;AACI,IAAAA,YAAW,UAAU,QAAQ,SAAU,QAAQ,QAAQ;AACnD,UAAI,QAAQ;AACZ,UAAI,UAAU,CAAE;AAChB,eAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,gBAAQ,KAAK,CAAC,IAAI,UAAU,EAAE;AAAA,MAC1C;AACQ,UAAI,gBAAgB,MAAM,KAAK,gBAAgB,MAAM,GAAG;AACpD,eAAO,KAAK,MAAM,EAAE,QAAQ,SAAU,WAAW;AAC7C,cAAI,eAAe,KAAK,QAAQ,SAAS,GAAG;AACxC,gBAAI,cAAc,OAAO,SAAS;AAClC,gBAAI,OAAO,SAAS,MAAM,aAAa;AACnC,kBAAI,SAAS,MAAM,WAAW,MAAM,OAAO,cAAc;AAAA,gBAAC;AAAA,gBACtD;AAAA,gBACA;AAAA,cAAS,GAAG,SAAS,KAAK,CAAC;AAG/B,kBAAI,WAAW,aAAa;AACxB,yBAAS,MAAM,oBAAoB,MAAM;AACzC,uBAAO,SAAS,IAAI;AAAA,cAChD;AAAA,YACA;AAAA,UACA,OACqB;AAGD,qBAAS,MAAM,oBAAoB,MAAM;AACzC,mBAAO,SAAS,IAAI,OAAO,SAAS;AAAA,UACxD;AAAA,QACA,CAAa;AACD,eAAO;AAAA,MACnB;AAEQ,aAAO;AAAA,IACV;AACD,IAAAA,YAAW,UAAU,sBAAsB,SAAU,OAAO;AACxD,UAAI,gBAAgB,KAAK,GAAG;AACxB,YAAI,CAAC,KAAK,WAAW,IAAI,KAAK,GAAG;AAC7B,cAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,oBAAQ,MAAM,MAAM,CAAC;AAAA,UACzC,OACqB;AACD,oBAAQ,SAAS,EAAE,WAAW,OAAO,eAAe,KAAK,EAAG,GAAE,KAAK;AAAA,UACvF;AACgB,eAAK,WAAW,IAAI,KAAK;AAAA,QACzC;AAAA,MACA;AACQ,aAAO;AAAA,IACV;AACD,WAAOA;AAAA,EACX,EAAG;AAAA;","names":["DeepMerger"],"sources":["../../../../../../../../../../../node_modules/@apollo/client/utilities/common/mergeDeep.js"],"sourcesContent":["import { __assign, __spreadArray } from \"tslib\";\nimport { isNonNullObject } from \"./objects.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function mergeDeep() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    return mergeDeepArray(sources);\n}\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray(sources) {\n    var target = sources[0] || {};\n    var count = sources.length;\n    if (count > 1) {\n        var merger = new DeepMerger();\n        for (var i = 1; i < count; ++i) {\n            target = merger.merge(target, sources[i]);\n        }\n    }\n    return target;\n}\nvar defaultReconciler = function (target, source, property) {\n    return this.merge(target[property], source[property]);\n};\nvar DeepMerger = /** @class */ (function () {\n    function DeepMerger(reconciler) {\n        if (reconciler === void 0) { reconciler = defaultReconciler; }\n        this.reconciler = reconciler;\n        this.isObject = isNonNullObject;\n        this.pastCopies = new Set();\n    }\n    DeepMerger.prototype.merge = function (target, source) {\n        var _this = this;\n        var context = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            context[_i - 2] = arguments[_i];\n        }\n        if (isNonNullObject(source) && isNonNullObject(target)) {\n            Object.keys(source).forEach(function (sourceKey) {\n                if (hasOwnProperty.call(target, sourceKey)) {\n                    var targetValue = target[sourceKey];\n                    if (source[sourceKey] !== targetValue) {\n                        var result = _this.reconciler.apply(_this, __spreadArray([target,\n                            source,\n                            sourceKey], context, false));\n                        // A well-implemented reconciler may return targetValue to indicate\n                        // the merge changed nothing about the structure of the target.\n                        if (result !== targetValue) {\n                            target = _this.shallowCopyForMerge(target);\n                            target[sourceKey] = result;\n                        }\n                    }\n                }\n                else {\n                    // If there is no collision, the target can safely share memory with\n                    // the source, and the recursion can terminate here.\n                    target = _this.shallowCopyForMerge(target);\n                    target[sourceKey] = source[sourceKey];\n                }\n            });\n            return target;\n        }\n        // If source (or target) is not an object, let source replace target.\n        return source;\n    };\n    DeepMerger.prototype.shallowCopyForMerge = function (value) {\n        if (isNonNullObject(value)) {\n            if (!this.pastCopies.has(value)) {\n                if (Array.isArray(value)) {\n                    value = value.slice(0);\n                }\n                else {\n                    value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);\n                }\n                this.pastCopies.add(value);\n            }\n        }\n        return value;\n    };\n    return DeepMerger;\n}());\nexport { DeepMerger };\n//# sourceMappingURL=mergeDeep.js.map"],"version":3}