{"file":"helpers.mjs","mappings":";;;;;;;;AACW,IAAA,SAAS,OAAO,UAAU;AAC9B,SAAS,UAAU,OAAO;AACtB,SAAA,UAAU,QAAQ,UAAU;AACvC;AAEgB,SAAA,wBAAwB,IAAI,SAAS;AACjD,MAAI,aAAa,GAAG,YAAY,KAAK,GAAG,IAAI,MAAM,GAAG;AACjD,MAAA,OAAO,eAAe,UAAU;AAChC,QAAI,SAAS;AACT,cAAQ,YACJ,CAAC,UAAU,EAAE,IAAI,EAAE,OACb,CAAC,UAAU,GAAG,IAAI,EAAE,IAChB,IAAA;AAAA,IAAA;AAGlB,QAAI,UAAU,EAAE,KAAK,CAAC,UAAU,GAAG,GAAG;AAC7B,WAAA;AAAA,IAAA;AAEL,QAAA,CAAC,UAAU,EAAE,GAAG;AAChB,aAAO,GAAG,OAAO,YAAY,GAAG,EAAE,OAAO,OAAO,OAAO,YAAY,OAAO,OAAO,WAC7E,KACE,KAAK,UAAU,EAAE,CAAC;AAAA,IAAA;AAAA,EAC5B;AAER;AACA,IAAI,gBAAgB;AAAA,EAChB,kBAAkB;AAAA,EAClB,aAAa;AAAA,EACb,eAAe;AAAA;AAAA;AAAA,EAGf,iBAAiB;AACrB;AACO,SAAS,gBAAgB,QAAQ;AAC7B,SAAA,QAAQ,eAAe,MAAM;AACxC;AACO,SAAS,sBAAsB,QAAQ;AAC1C,MAAI,QAAQ,OAAO;AACZ,SAAA,UAAU,SAAS,cAAc,kBAAkB;AAC9D;AACgB,SAAA,2BAA2B,OAAO,mBAAmB;AAC1D,SAAA,YAAY,iBAAiB,IAChC,MAAM,IAAI,kBAAkB,OAAO,YAAY,IAC7C,qBAAqB,kBAAkB;AACjD;AACO,IAAI,wBAAwB;AAC5B,SAAS,uBAAuB,gBAAgB;AAC/C,MAAA,QAAQ,eAAe,MAAM,qBAAqB;AAC/C,SAAA,QAAQ,MAAM,CAAC,IAAI;AAC9B;AACgB,SAAA,0BAA0B,cAAc,QAAQ,WAAW;AACnE,MAAA,gBAAgB,MAAM,GAAG;AACzB,WAAO,QAAQ,MAAM,IACjB,OAAO,MAAM,SAAU,MAAM;AAClB,aAAA,0BAA0B,cAAc,MAAM,SAAS;AAAA,IACjE,CAAA,IACC,aAAa,WAAW,MAAM,SAAU,OAAO;AAC7C,UAAI,QAAQ,KAAK,KAAK,cAAc,OAAO,SAAS,GAAG;AAC/C,YAAA,MAAM,uBAAuB,KAAK;AACtC,eAAQ,OAAO,KAAK,QAAQ,GAAG,MAC1B,CAAC,MAAM,gBACJ,0BAA0B,MAAM,cAAc,OAAO,GAAG,GAAG,SAAS;AAAA,MAAA;AAOzE,aAAA;AAAA,IAAA,CACV;AAAA,EAAA;AAEF,SAAA;AACX;AACO,SAAS,wBAAwB,OAAO;AACpC,SAAA,gBAAgB,KAAK,KAAK,CAAC,YAAY,KAAK,KAAK,CAAC,QAAQ,KAAK;AAC1E;AACO,SAAS,4BAA4B;AACxC,SAAO,IAAI,WAAW;AAC1B;AACgB,SAAA,uBAAuB,UAAU,WAAW;AAGxD,MAAI,cAAc,kBAAkB,uBAAuB,QAAQ,CAAC;AAC7D,SAAA;AAAA,IACH;AAAA,IACA,gBAAgB,SAAU,MAAM;AACxB,UAAA,MAAM,YAAY,IAAI;AACtB,UAAA,CAAC,OAAO,WAAW;AACb,cAAA,UAAU,OAAO,IAAI;AAAA,MAAA;AAE/B,aAAO,OAAO;AAAA,IAAA;AAAA,EAEtB;AACJ;","names":[],"sources":["../../../../../../../../../../../node_modules/@apollo/client/cache/inmemory/helpers.js"],"sourcesContent":["import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude, isNonNullObject, compact, createFragmentMap, getFragmentDefinitions, isArray, } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function isNullish(value) {\n    return value === null || value === void 0;\n}\nexport { isArray };\nexport function defaultDataIdFromObject(_a, context) {\n    var __typename = _a.__typename, id = _a.id, _id = _a._id;\n    if (typeof __typename === \"string\") {\n        if (context) {\n            context.keyObject =\n                !isNullish(id) ? { id: id }\n                    : !isNullish(_id) ? { _id: _id }\n                        : void 0;\n        }\n        // If there is no object.id, fall back to object._id.\n        if (isNullish(id) && !isNullish(_id)) {\n            id = _id;\n        }\n        if (!isNullish(id)) {\n            return \"\".concat(__typename, \":\").concat(typeof id === \"number\" || typeof id === \"string\" ?\n                id\n                : JSON.stringify(id));\n        }\n    }\n}\nvar defaultConfig = {\n    dataIdFromObject: defaultDataIdFromObject,\n    addTypename: true,\n    resultCaching: true,\n    // Thanks to the shouldCanonizeResults helper, this should be the only line\n    // you have to change to reenable canonization by default in the future.\n    canonizeResults: false,\n};\nexport function normalizeConfig(config) {\n    return compact(defaultConfig, config);\n}\nexport function shouldCanonizeResults(config) {\n    var value = config.canonizeResults;\n    return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n    return isReference(objectOrReference) ?\n        store.get(objectOrReference.__ref, \"__typename\")\n        : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n    var match = storeFieldName.match(TypeOrFieldNameRegExp);\n    return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n    if (isNonNullObject(result)) {\n        return isArray(result) ?\n            result.every(function (item) {\n                return selectionSetMatchesResult(selectionSet, item, variables);\n            })\n            : selectionSet.selections.every(function (field) {\n                if (isField(field) && shouldInclude(field, variables)) {\n                    var key = resultKeyNameFromField(field);\n                    return (hasOwn.call(result, key) &&\n                        (!field.selectionSet ||\n                            selectionSetMatchesResult(field.selectionSet, result[key], variables)));\n                }\n                // If the selection has been skipped with @skip(true) or\n                // @include(false), it should not count against the matching. If\n                // the selection is not a field, it must be a fragment (inline or\n                // named). We will determine if selectionSetMatchesResult for that\n                // fragment when we get to it, so for now we return true.\n                return true;\n            });\n    }\n    return false;\n}\nexport function storeValueIsStoreObject(value) {\n    return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n    return new DeepMerger();\n}\nexport function extractFragmentContext(document, fragments) {\n    // FragmentMap consisting only of fragments defined directly in document, not\n    // including other fragments registered in the FragmentRegistry.\n    var fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n    return {\n        fragmentMap: fragmentMap,\n        lookupFragment: function (name) {\n            var def = fragmentMap[name];\n            if (!def && fragments) {\n                def = fragments.lookup(name);\n            }\n            return def || null;\n        },\n    };\n}\n//# sourceMappingURL=helpers.js.map"],"version":3}