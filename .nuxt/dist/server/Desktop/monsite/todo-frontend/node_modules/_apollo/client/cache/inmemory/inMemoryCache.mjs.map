{"version":3,"file":"inMemoryCache.mjs","sources":["../../../../../../../../../../../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js"],"sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport \"./fixPolyfills.js\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { ApolloCache } from \"../core/cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { addTypenameToDocument, isReference, DocumentTransform, canonicalStringify, print, cacheSizes, } from \"../../utilities/index.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport { getInMemoryCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nvar InMemoryCache = /** @class */ (function (_super) {\n    __extends(InMemoryCache, _super);\n    function InMemoryCache(config) {\n        if (config === void 0) { config = {}; }\n        var _this = _super.call(this) || this;\n        _this.watches = new Set();\n        _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n        // Override the default value, since InMemoryCache result objects are frozen\n        // in development and expected to remain logically immutable in production.\n        _this.assumeImmutableResults = true;\n        _this.makeVar = makeVar;\n        _this.txCount = 0;\n        _this.config = normalizeConfig(config);\n        _this.addTypename = !!_this.config.addTypename;\n        _this.policies = new Policies({\n            cache: _this,\n            dataIdFromObject: _this.config.dataIdFromObject,\n            possibleTypes: _this.config.possibleTypes,\n            typePolicies: _this.config.typePolicies,\n        });\n        _this.init();\n        return _this;\n    }\n    InMemoryCache.prototype.init = function () {\n        // Passing { resultCaching: false } in the InMemoryCache constructor options\n        // will completely disable dependency tracking, which will improve memory\n        // usage but worsen the performance of repeated reads.\n        var rootStore = (this.data = new EntityStore.Root({\n            policies: this.policies,\n            resultCaching: this.config.resultCaching,\n        }));\n        // When no optimistic writes are currently active, cache.optimisticData ===\n        // cache.data, so there are no additional layers on top of the actual data.\n        // When an optimistic update happens, this.optimisticData will become a\n        // linked list of EntityStore Layer objects that terminates with the\n        // original this.data cache object.\n        this.optimisticData = rootStore.stump;\n        this.resetResultCache();\n    };\n    InMemoryCache.prototype.resetResultCache = function (resetResultIdentities) {\n        var _this = this;\n        var previousReader = this.storeReader;\n        var fragments = this.config.fragments;\n        // The StoreWriter is mostly stateless and so doesn't really need to be\n        // reset, but it does need to have its writer.storeReader reference updated,\n        // so it's simpler to update this.storeWriter as well.\n        this.storeWriter = new StoreWriter(this, (this.storeReader = new StoreReader({\n            cache: this,\n            addTypename: this.addTypename,\n            resultCacheMaxSize: this.config.resultCacheMaxSize,\n            canonizeResults: shouldCanonizeResults(this.config),\n            canon: resetResultIdentities ? void 0 : (previousReader && previousReader.canon),\n            fragments: fragments,\n        })), fragments);\n        this.maybeBroadcastWatch = wrap(function (c, options) {\n            return _this.broadcastWatch(c, options);\n        }, {\n            max: this.config.resultCacheMaxSize ||\n                cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] ||\n                5000 /* defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] */,\n            makeCacheKey: function (c) {\n                // Return a cache key (thus enabling result caching) only if we're\n                // currently using a data store that can track cache dependencies.\n                var store = c.optimistic ? _this.optimisticData : _this.data;\n                if (supportsResultCaching(store)) {\n                    var optimistic = c.optimistic, id = c.id, variables = c.variables;\n                    return store.makeCacheKey(c.query, \n                    // Different watches can have the same query, optimistic\n                    // status, rootId, and variables, but if their callbacks are\n                    // different, the (identical) result needs to be delivered to\n                    // each distinct callback. The easiest way to achieve that\n                    // separation is to include c.callback in the cache key for\n                    // maybeBroadcastWatch calls. See issue #5733.\n                    c.callback, canonicalStringify({ optimistic: optimistic, id: id, variables: variables }));\n                }\n            },\n        });\n        // Since we have thrown away all the cached functions that depend on the\n        // CacheGroup dependencies maintained by EntityStore, we should also reset\n        // all CacheGroup dependency information.\n        new Set([this.data.group, this.optimisticData.group]).forEach(function (group) {\n            return group.resetCaching();\n        });\n    };\n    InMemoryCache.prototype.restore = function (data) {\n        this.init();\n        // Since calling this.init() discards/replaces the entire StoreReader, along\n        // with the result caches it maintains, this.data.replace(data) won't have\n        // to bother deleting the old data.\n        if (data)\n            this.data.replace(data);\n        return this;\n    };\n    InMemoryCache.prototype.extract = function (optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return (optimistic ? this.optimisticData : this.data).extract();\n    };\n    InMemoryCache.prototype.read = function (options) {\n        var \n        // Since read returns data or null, without any additional metadata\n        // about whether/where there might have been missing fields, the\n        // default behavior cannot be returnPartialData = true (like it is\n        // for the diff method), since defaulting to true would violate the\n        // integrity of the T in the return type. However, partial data may\n        // be useful in some cases, so returnPartialData:true may be\n        // specified explicitly.\n        _a = options.returnPartialData, \n        // Since read returns data or null, without any additional metadata\n        // about whether/where there might have been missing fields, the\n        // default behavior cannot be returnPartialData = true (like it is\n        // for the diff method), since defaulting to true would violate the\n        // integrity of the T in the return type. However, partial data may\n        // be useful in some cases, so returnPartialData:true may be\n        // specified explicitly.\n        returnPartialData = _a === void 0 ? false : _a;\n        try {\n            return (this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData: returnPartialData })).result || null);\n        }\n        catch (e) {\n            if (e instanceof MissingFieldError) {\n                // Swallow MissingFieldError and return null, so callers do not need to\n                // worry about catching \"normal\" exceptions resulting from incomplete\n                // cache data. Unexpected errors will be re-thrown. If you need more\n                // information about which fields were missing, use cache.diff instead,\n                // and examine diffResult.missing.\n                return null;\n            }\n            throw e;\n        }\n    };\n    InMemoryCache.prototype.write = function (options) {\n        try {\n            ++this.txCount;\n            return this.storeWriter.writeToStore(this.data, options);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.modify = function (options) {\n        if (hasOwn.call(options, \"id\") && !options.id) {\n            // To my knowledge, TypeScript does not currently provide a way to\n            // enforce that an optional property?:type must *not* be undefined\n            // when present. That ability would be useful here, because we want\n            // options.id to default to ROOT_QUERY only when no options.id was\n            // provided. If the caller attempts to pass options.id with a\n            // falsy/undefined value (perhaps because cache.identify failed), we\n            // should not assume the goal was to modify the ROOT_QUERY object.\n            // We could throw, but it seems natural to return false to indicate\n            // that nothing was modified.\n            return false;\n        }\n        var store = ((options.optimistic) // Defaults to false.\n        ) ?\n            this.optimisticData\n            : this.data;\n        try {\n            ++this.txCount;\n            return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.diff = function (options) {\n        return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || \"ROOT_QUERY\", config: this.config }));\n    };\n    InMemoryCache.prototype.watch = function (watch) {\n        var _this = this;\n        if (!this.watches.size) {\n            // In case we previously called forgetCache(this) because\n            // this.watches became empty (see below), reattach this cache to any\n            // reactive variables on which it previously depended. It might seem\n            // paradoxical that we're able to recall something we supposedly\n            // forgot, but the point of calling forgetCache(this) is to silence\n            // useless broadcasts while this.watches is empty, and to allow the\n            // cache to be garbage collected. If, however, we manage to call\n            // recallCache(this) here, this cache object must not have been\n            // garbage collected yet, and should resume receiving updates from\n            // reactive variables, now that it has a watcher to notify.\n            recallCache(this);\n        }\n        this.watches.add(watch);\n        if (watch.immediate) {\n            this.maybeBroadcastWatch(watch);\n        }\n        return function () {\n            // Once we remove the last watch from this.watches, cache.broadcastWatches\n            // no longer does anything, so we preemptively tell the reactive variable\n            // system to exclude this cache from future broadcasts.\n            if (_this.watches.delete(watch) && !_this.watches.size) {\n                forgetCache(_this);\n            }\n            // Remove this watch from the LRU cache managed by the\n            // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n            // leaks involving the closure of watch.callback.\n            _this.maybeBroadcastWatch.forget(watch);\n        };\n    };\n    InMemoryCache.prototype.gc = function (options) {\n        var _a;\n        canonicalStringify.reset();\n        print.reset();\n        this.addTypenameTransform.resetCache();\n        (_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.resetCaches();\n        var ids = this.optimisticData.gc();\n        if (options && !this.txCount) {\n            if (options.resetResultCache) {\n                this.resetResultCache(options.resetResultIdentities);\n            }\n            else if (options.resetResultIdentities) {\n                this.storeReader.resetCanon();\n            }\n        }\n        return ids;\n    };\n    // Call this method to ensure the given root ID remains in the cache after\n    // garbage collection, along with its transitive child entities. Note that\n    // the cache automatically retains all directly written entities. By default,\n    // the retainment persists after optimistic updates are removed. Pass true\n    // for the optimistic argument if you would prefer for the retainment to be\n    // discarded when the top-most optimistic layer is removed. Returns the\n    // resulting (non-negative) retainment count.\n    InMemoryCache.prototype.retain = function (rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).retain(rootId);\n    };\n    // Call this method to undo the effect of the retain method, above. Once the\n    // retainment count falls to zero, the given ID will no longer be preserved\n    // during garbage collection, though it may still be preserved by other safe\n    // entities that refer to it. Returns the resulting (non-negative) retainment\n    // count, in case that's useful.\n    InMemoryCache.prototype.release = function (rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).release(rootId);\n    };\n    // Returns the canonical ID for a given StoreObject, obeying typePolicies\n    // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n    // the object must contain a __typename and any primary key fields required\n    // to identify entities of that type. If you pass a query result object, be\n    // sure that none of the primary key fields have been renamed by aliasing.\n    // If you pass a Reference object, its __ref ID string will be returned.\n    InMemoryCache.prototype.identify = function (object) {\n        if (isReference(object))\n            return object.__ref;\n        try {\n            return this.policies.identify(object)[0];\n        }\n        catch (e) {\n            globalThis.__DEV__ !== false && invariant.warn(e);\n        }\n    };\n    InMemoryCache.prototype.evict = function (options) {\n        if (!options.id) {\n            if (hasOwn.call(options, \"id\")) {\n                // See comment in modify method about why we return false when\n                // options.id exists but is falsy/undefined.\n                return false;\n            }\n            options = __assign(__assign({}, options), { id: \"ROOT_QUERY\" });\n        }\n        try {\n            // It's unlikely that the eviction will end up invoking any other\n            // cache update operations while it's running, but {in,de}crementing\n            // this.txCount still seems like a good idea, for uniformity with\n            // the other update methods.\n            ++this.txCount;\n            // Pass this.data as a limit on the depth of the eviction, so evictions\n            // during optimistic updates (when this.data is temporarily set equal to\n            // this.optimisticData) do not escape their optimistic Layer.\n            return this.optimisticData.evict(options, this.data);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.reset = function (options) {\n        var _this = this;\n        this.init();\n        canonicalStringify.reset();\n        if (options && options.discardWatches) {\n            // Similar to what happens in the unsubscribe function returned by\n            // cache.watch, applied to all current watches.\n            this.watches.forEach(function (watch) { return _this.maybeBroadcastWatch.forget(watch); });\n            this.watches.clear();\n            forgetCache(this);\n        }\n        else {\n            // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n            // this.broadcastWatches() triggers a broadcast to every current watcher\n            // (letting them know their data is now missing). This default behavior is\n            // convenient because it means the watches do not have to be manually\n            // reestablished after resetting the cache. To prevent this broadcast and\n            // cancel all watches, pass true for options.discardWatches.\n            this.broadcastWatches();\n        }\n        return Promise.resolve();\n    };\n    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n        if (newOptimisticData !== this.optimisticData) {\n            this.optimisticData = newOptimisticData;\n            this.broadcastWatches();\n        }\n    };\n    InMemoryCache.prototype.batch = function (options) {\n        var _this = this;\n        var update = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;\n        var updateResult;\n        var perform = function (layer) {\n            var _a = _this, data = _a.data, optimisticData = _a.optimisticData;\n            ++_this.txCount;\n            if (layer) {\n                _this.data = _this.optimisticData = layer;\n            }\n            try {\n                return (updateResult = update(_this));\n            }\n            finally {\n                --_this.txCount;\n                _this.data = data;\n                _this.optimisticData = optimisticData;\n            }\n        };\n        var alreadyDirty = new Set();\n        if (onWatchUpdated && !this.txCount) {\n            // If an options.onWatchUpdated callback is provided, we want to call it\n            // with only the Cache.WatchOptions objects affected by options.update,\n            // but there might be dirty watchers already waiting to be broadcast that\n            // have nothing to do with the update. To prevent including those watchers\n            // in the post-update broadcast, we perform this initial broadcast to\n            // collect the dirty watchers, so we can re-dirty them later, after the\n            // post-update broadcast, allowing them to receive their pending\n            // broadcasts the next time broadcastWatches is called, just as they would\n            // if we never called cache.batch.\n            this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function (watch) {\n                    alreadyDirty.add(watch);\n                    return false;\n                } }));\n        }\n        if (typeof optimistic === \"string\") {\n            // Note that there can be multiple layers with the same optimistic ID.\n            // When removeOptimistic(id) is called for that id, all matching layers\n            // will be removed, and the remaining layers will be reapplied.\n            this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n        }\n        else if (optimistic === false) {\n            // Ensure both this.data and this.optimisticData refer to the root\n            // (non-optimistic) layer of the cache during the update. Note that\n            // this.data could be a Layer if we are currently executing an optimistic\n            // update function, but otherwise will always be an EntityStore.Root\n            // instance.\n            perform(this.data);\n        }\n        else {\n            // Otherwise, leave this.data and this.optimisticData unchanged and run\n            // the update with broadcast batching.\n            perform();\n        }\n        if (typeof removeOptimistic === \"string\") {\n            this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n        }\n        // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n        // takes the else branch and calls this.broadcastWatches(options), which\n        // does nothing when this.txCount > 0.\n        if (onWatchUpdated && alreadyDirty.size) {\n            this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function (watch, diff) {\n                    var result = onWatchUpdated.call(this, watch, diff);\n                    if (result !== false) {\n                        // Since onWatchUpdated did not return false, this diff is\n                        // about to be broadcast to watch.callback, so we don't need\n                        // to re-dirty it with the other alreadyDirty watches below.\n                        alreadyDirty.delete(watch);\n                    }\n                    return result;\n                } }));\n            // Silently re-dirty any watches that were already dirty before the update\n            // was performed, and were not broadcast just now.\n            if (alreadyDirty.size) {\n                alreadyDirty.forEach(function (watch) { return _this.maybeBroadcastWatch.dirty(watch); });\n            }\n        }\n        else {\n            // If alreadyDirty is empty or we don't have an onWatchUpdated\n            // function, we don't need to go to the trouble of wrapping\n            // options.onWatchUpdated.\n            this.broadcastWatches(options);\n        }\n        return updateResult;\n    };\n    InMemoryCache.prototype.performTransaction = function (update, optimisticId) {\n        return this.batch({\n            update: update,\n            optimistic: optimisticId || optimisticId !== null,\n        });\n    };\n    InMemoryCache.prototype.transformDocument = function (document) {\n        return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n    };\n    InMemoryCache.prototype.fragmentMatches = function (fragment, typename) {\n        return this.policies.fragmentMatches(fragment, typename);\n    };\n    InMemoryCache.prototype.lookupFragment = function (fragmentName) {\n        var _a;\n        return ((_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.lookup(fragmentName)) || null;\n    };\n    InMemoryCache.prototype.broadcastWatches = function (options) {\n        var _this = this;\n        if (!this.txCount) {\n            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c, options); });\n        }\n    };\n    InMemoryCache.prototype.addFragmentsToDocument = function (document) {\n        var fragments = this.config.fragments;\n        return fragments ? fragments.transform(document) : document;\n    };\n    InMemoryCache.prototype.addTypenameToDocument = function (document) {\n        if (this.addTypename) {\n            return this.addTypenameTransform.transformDocument(document);\n        }\n        return document;\n    };\n    // This method is wrapped by maybeBroadcastWatch, which is called by\n    // broadcastWatches, so that we compute and broadcast results only when\n    // the data that would be broadcast might have changed. It would be\n    // simpler to check for changes after recomputing a result but before\n    // broadcasting it, but this wrapping approach allows us to skip both\n    // the recomputation and the broadcast, in most cases.\n    InMemoryCache.prototype.broadcastWatch = function (c, options) {\n        var lastDiff = c.lastDiff;\n        // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n        // currently requires no additional properties, so we can use c (a\n        // WatchOptions object) as DiffOptions, without having to allocate a new\n        // object, and without having to enumerate the relevant properties (query,\n        // variables, etc.) explicitly. There will be some additional properties\n        // (lastDiff, callback, etc.), but cache.diff ignores them.\n        var diff = this.diff(c);\n        if (options) {\n            if (c.optimistic && typeof options.optimistic === \"string\") {\n                diff.fromOptimisticTransaction = true;\n            }\n            if (options.onWatchUpdated &&\n                options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n                // Returning false from the onWatchUpdated callback will prevent\n                // calling c.callback(diff) for this watcher.\n                return;\n            }\n        }\n        if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n            c.callback((c.lastDiff = diff), lastDiff);\n        }\n    };\n    return InMemoryCache;\n}(ApolloCache));\nexport { InMemoryCache };\nif (globalThis.__DEV__ !== false) {\n    InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n//# sourceMappingURL=inMemoryCache.js.map"],"names":["InMemoryCache","_a"],"mappings":"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","x_google_ignoreList":[0]}